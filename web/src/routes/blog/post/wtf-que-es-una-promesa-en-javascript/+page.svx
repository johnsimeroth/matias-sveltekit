
---
date: 2022-09-07T02:51:11Z
banner: https://cdn.sanity.io/images/cyypawp1/production/2e83c37b5506427db241f046575270124020a1fd-1280x710.png
keywords: 
- Javascript
- Javascript Promises
- Javascript Promesas
- Interview Questions
- Preguntas de Entrevista
- promises in javascript
- promesas en javascript
- async
- await
- async/await
title: "WTF ¬øQu√© es una promesa en Javascript?"
description: "Una Promesa, es un objeto que permite manipular acciones as√≠ncronas dentro de un lenguaje de un solo hilo como Javascript.
¬øWTF? "
bannerCredit: undefined
tag: Posts
---
# ¬øWTF son las promesas?



> **Promises es es un objeto para manipular acciones as√≠ncronas dentro de Javascript.**

Javascript es un lenguaje que se ejecuta en el browser con la idea de dar dinamismo al contenido ah√≠ desplegado, esto implica que muchas operaciones se deben dar de forma as√≠ncrona. Dado que los motores de javascript son _"Single Threaded"_, es decir, Javascript no maneja m√∫ltiples hilos es necesario implementar otra estrategia para la asincron√≠a.

Una **Promise** es un objeto que produce un valor que estar√° disponible en alg√∫n momento futuro.

El concepto de promesa, **future** o **deferred** es una construcci√≥n utilizada para ‚Äúsincronizar‚Äù la ejecuci√≥n de instrucciones en lenguajes concurrentes. Este concepto describe un objeto cuyo valor inicial es desconocido.



El desarrollo web trajo nueva vida al concepto dada su naturaleza as√≠ncrona y el modelo de `request-response` utilizado. (solicitar y obtener datos mediante una red donde el solicitante queda a la "espera" de una respuesta).

> Si te interesa saber m√°s del concepto de **promises y futures** puedes encontrar el [paper original aqu√≠](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.9692&rep=rep1&type=pdf) o en [esta secci√≥n sobre concurrencia](https://www.braveclojure.com/concurrency/) del libro ‚ÄúClojure for the Brave and True‚Äù



Las **Promises** como hoy las conocemos no llegaron a Javascript hasta la versi√≥n ES6, antes de eso todo era un caos y cada quien implementaba comportamientos as√≠ncronos como mejor le pareciera ü§Ø

> Eras muy joven pero antes teniamos m√∫ltiples librer√≠as para crear promesas como por ejemplo [bluebird](http://bluebirdjs.com/docs/getting-started.html) o [q](https://github.com/kriskowal/q) 

## ¬øC√≥mo funcionan las promesas?

Un promesa es un objeto, y como tal tiene varios atributos y m√©todos que nos permiten trabajar con el. La idea de este objeto es poder acceder y trabajar con el de forma `sincrona` pero cuyo valor es `asincrono` . Un gato de Schr√∂dinger.

Una promesa tiene 3 estados.

* **Pending:** Es el valor inicial, indicando que est√° a la espera de que ‚Äúel trabajo‚Äù sea realizado.
* **Fullfilled**: Cuando la operaci√≥n se ejecuta de forma existosa.
* **Rejected:** Cuando la operaci√≥n falla de alguna manera.

Ahora bien, estos estados no son expuestos como tal, una promesa es m√°s bien ‚Äúuna caja negra‚Äù en donde s√≥lo la funci√≥n que creo la promesa tiene conocimiento de su propio estado.

## ¬øC√≥mo se crea una promesa?

Suficiente texto, algo de c√≥digo

```javascript
const sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time));

sleep(3000)

console.log('¬øFuncion√≥ la promesa?')
```

  
**¬øQu√© ocurre al ejecutar este c√≥digo?**

Nada fuera de lo esperado üòÖ.

En este c√≥digo creamos una funci√≥n `sleep` que recibe el par√°metro `time`, un n√∫mero y retorna una promesa.

Para crear una promesa usamos su constructor y la palabra reserva `new`. La promesa recibe una funci√≥n tipo `callback` como √∫nico argumento. Esta funci√≥n recibe dos par√°metros. `resolve` y `reject`.

Estas funciones `resolve` y `reject` son funciones pre-definidas por el motor de Javascript para manejar los estados de la promesa, nosotros s√≥lo debemos utilizarlas cuando corresponde.

* `resolve` Es utilizado para marcar que el proceso de la promesa termin√≥ de forma exitosa. `resolve` acepta un par√°metro que es retornado como resultado de la ejecuci√≥n.
* `reject` Se usa para determinar cuando el proceso fall√≥, recibe un argumento que indica la raz√≥n del **rechazo** de la promesa.

Entonces, en el c√≥digo, nuestra funci√≥n callback es:

```javascript
(resolve, reject) => setTimeout(resolve, time)
```

Donde, `time` es el argumento de la funci√≥n externa (üëã _Mira! una closure salvaje a aparecido_). `setTimeout` ejecutar√° la funci√≥n que se usa como argumento cuando el tiempo definido pase, es decir cuando `time` se cumpla. La funci√≥n que pasamos como argumento es `resolve`, entonces `setTimeout` ejecutar√° `resolve` cuando el tiempo indicado termine.

>Si quieres saber m√°s sobre el concepto de closures te comparto dos art√≠culos que escrib√≠ al respecto.

> Uno que puedes encontrar en [FreeCodeCamp (en espa√±ol)](https://www.freecodecamp.org/espanol/news/que-es-un-closure-en-javascript/) y otro similar en [en mi sitio web](https://matiashernandez.dev/blog/post/que-es-un-closure-en-javascript)



Esta promesa en particular no falla jamas, por lo que podemos reescribirla as√≠



```javascript
const sleep = time => new Promise((resolve) => setTimeout(resolve, time));
```

Simplemente, eliminando el argumento `reject`.

> **Solo puedes utilizar un s√≥lo resultado o error dentro de una promesa.**

> La funci√≥n "ejecutora" s√≥lo puede tener una llamada **y solo una** a `resolve` o una a `reject`. Estas funciones cambian el estado de la promesa y este cambio de estado es √∫nico e irreversible.

> **Se recomienda rechazar con errores**

> El m√©todo `reject` acepta cualquier valor (al igual que `resolve`) pero dado el contexto de "rechazo‚Äù, se recomienda usar objetos `Error` para indicar la raz√≥n del rechazo.

**¬øPor qu√© el**¬†**`console.log`**¬†**no se ejecuta despu√©s de 3 segundos?**

Esto es por que nuestro c√≥digo no indica que se espere el resultado de la promesa.

Podemos pensar en la promesa como un enlace entre a funci√≥n as√≠ncrona encerrada en la caja negra y el c√≥digo que necesita consumir su resultado. Para esto, `Promise` permite registrar o "suscribirse" a la espera del resultado usando los m√©todos `.then`, `.catch`, `.finally`. Una `Promise` es un objeto `theneable`.

### .then

El m√©todo `.then` es el m√°s importante y fundamental, es el que nos permite "leer‚Äù el contenido de la caja negra, su sintaxis es

```javascript
promise.then(
	function(result) {},
	function(error) {}
);
```

Es decir, recibe dos argumentos tipo funci√≥n para manejar cada uno de los posibles estados de la promesa: `Fullfilled` y `Rejected` .

El primer argumento es una funci√≥n que se ejecutar√° cuando la promesa es resuelta existosamente, es decir, cuando se usa `resolve`. Esta funci√≥n recibe como argumento el valor pasado al m√©todo `resolve`.

El segundo argumento, es otra funci√≥n pero que esta vez se ejecuta cuando la promesa es rechazada, y recibe como par√°metro la raz√≥n de ese rechazo: el valor pasado a `reject`.

Entonces, ahora podemos modificar nuestro ejemplo utilizando `.then`

```javascript
const sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time));

sleep(3000).then(() => {
	console.log('¬øFuncion√≥ la promesa?')
})
```

Ahora, concatenamos la ejecuci√≥n de `console.log` a la espera de que la promesa `sleep` se cumpla y en ese momento se muestra el mensaje. Y como en nuestro caso `resolve` no recibe ning√∫n valor, nuestro funci√≥n de "√®xito" tampoco recibe par√°metros y solo se ejecuta.

Es posible separar el manejo de errores y de ejecuciones exitosas para dar un poco de legibilidad al c√≥digo, para eso podemos s√≥lo usar el primer argumento de `.then` y luego usar el siguiente m√©todo: `.catch`

### .catch

Este m√©todo s√≥lo se ejecuta cuando la promesa fue rechazada usando `reject`. Este m√©todo es un an√°logo de usar `.then(null, f)` (siendo `f` una funci√≥n), existe solo por claridad de su ejecuci√≥n.

¬øPero que ocurre si quieres ejecutar alg√∫n proceso sin importar si la promesa se cumpli√≥ o no?. Entra `.finally`

### .finally

Muy similar a como funciona `.finally` en un bloque `try/catch` este ejecutar√° siempre la funci√≥n que se le pase como argumento, independiente del resultado de la promesa.

* La funci√≥n utilizada dentro de `finally` no recibe argumentos. No sabemos si la promesa fue exitosa o no.
* Puedes concatenar otros ‚Äúmanejadores‚Äù despu√©s de `finally`.



```javascript
const sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time));

sleep(3000)
.finally(() => console.log('Promesa est√° lista'))
.then(() => {
	console.log('¬øFuncion√≥ la promesa?')
})
.catch(err => {
	console.log(erro)
})
```

  
Algunas ‚Äúreglas‚Äù

* Una promesa es `thenable`, el objeto siempre otorga un m√©todo `then`
* Una promesa pendiente puede transicionar al estado `fullfilled` or `rejected`
* Una promesa en estado `fullfilled` o `rejected` se conoce como `settled` y no puede cambiar de estado nuevamente.

### Encadenamiento

Dado que `.then` siempre retorna una nueva promesa, es posible encadenar promesas otorgando mas control sobre como se manejan los resultados y errores, un ejemplo muy utilizado en el mundo real es trabajando con la api `fetch`.

La [api](https://developer.mozilla.org/es/docs/Web/API/Fetch_API)¬†[`fetch`](https://developer.mozilla.org/es/docs/Web/API/Fetch_API) es la interfaz nativa de javascript para obtener recursos externos y funciona como una Promesa.



```javascript
const obtenerDatos = () => {
	return fetch('/algunaUrl/)
}

obtenerDatos()
		.then(response => response.json())
		.then(json => json)
		.then(print => {
			console.log(print)
		})
		.catch(error => console.error(error)
```

En este ejemplo creamos una funci√≥n que utiliza la api `fetch` para obtener datos de alg√∫n endpoint y retorna una promesa. Podemos entonces usar `.then` para leer la respuesta obtenida.

La respuesta de una llamada a `fetch` es un objeto `Response` que tiene un m√©todo que permite obtener el cuerpo de la respuesta en forma json y que es en si mismo una promesa.

`.then(response => response.json())`

Usamos el retorno impl√≠cito de la arrow function para retornar inmediatamente la promesa. Luego volvemos a encadenar usando `then` y obtenemos el valor retornado previamente

`. then(json => json)`

En este punto, podemos ya utilizar el valor, pero solo por propositos de demostraci√≥n, lo retornamos `json => json` y volvemos a encadenar `.then(print => {})` creando una nueva funci√≥n que se encarga de imprimir el resultado.

Finalmente encadeamos un `.catch` para capturar cualquier error.  
Algunos otros m√©todos.

El objeto `Promise` nos ofrece algunos otros m√©todos "utilitarios‚Äù:

* `Promise.all` permite obtener el resultado de un grupo de promesas. Recibe como argumento un `iterable` como un arreglo de promesas y espera a que todas las promesas se cumplan o a que una sea rechazada para retornar. Si todas las promesas se cumplen, retornar√° al siguiente`.then` un arreglo con los resultados en el mismo orden que las promesas pasadas como argumento.
* `Promise.race` Tambi√©n recibe un arreglo de promesas pero retorna tan pronto **una** promesa se cumple o rechaza.
* `Promise.allSettled` Tambi√©n recibe un `iterable` de promesas y espera a que todas las promesas hayan terminado sin importar si fueron exitosas o rechazadas. Retorna una promesa con un arreglo de objetos con los resultados de cada promesa pasada como argumento.
* `Promise.any`. Recibe un `iterable` y retorna tan pronto una de las promesas termina exitosamente.

> **Desaf√≠o**

> Escribe una promesa que te permita cargar un script de forma as√≠ncrona y te comunique cuando se ejecuto exitosamente o fall√≥. Puedes usar el [c√≥digo base disponible aqu√≠.](https://jsitor.com/60HE9qayf)